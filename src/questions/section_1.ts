import { QuestionCard } from "./types";


export const questionCards_1: QuestionCard[] = [
  {
    questionText: "JavaScript - это",
    answerOptions: [
      {
        id: "1.1.1",
        name: "q1.1",
        value: "1",
        text: "язык для создания и управления динамическим содержимым веб-страниц и придания сайту интерактивности",
      },
      {
        id: "1.1.2",
        name: "q1.1",
        value: "0",
        text: "текст ответа  номер 2",
      },
      {
        id: "1.1.3",
        name: "q1.1",
        value: "0",
        text: "тескт ответа номер 3",
      }
    ],
    feedbackText: "JavaScript - язык программирования, который позволяет вам создать динамически обновляемый контент, управляет мультимедиа, анимирует изображения. JavaScript это язык, который позволяет вам применять сложные вещи на web странице — каждый раз, когда на web странице происходит что-то большее, чем просто её статичное отображение — отображение периодически обновляемого контента, или интерактивных карт, или анимация 2D/3D графики, или прокрутка видео в проигрывателе, и т.д. — можете быть уверены, что скорее всего, не обошлось без JavaScript."
  },
  {
    questionText: "Под динамической типизацией JS подразумевается:",
    answerOptions: [
      {
        id: "1.2.1",
        name: "q1.2",
        value: "0",
        text: "тескт ответа номер 1",
      },
      {
        id: "1.2.2",
        name: "q1.2",
        value: "1",
        text: "связываение переменной с типом в момент присваивания значения, а не в момент объявления переменной, т.о., в различных участках программы одна и та же переменная может принимать значения разных типов.",
      },
      {
        id: "1.2.3",
        name: "q1.2",
        value: "0",
        text: "тескт ответа номер 3",
      }
    ],
    feedbackText: "Динамическая типизация — это возможность одного типа данных превращаться в другой. Число может стать строкой, строка — числом. А объект — булевым значением. Наиболее часто встречающиеся виды динамической типизации: преобразование в строку (В JS если что то сложить со строкой, то это выражение превратится в строку), преобразование в число (унарный плюс конвертирует объект и строку в числовой тип данных), преобразование типов данных в булевы значения."
  },
  {
    questionText: "Что можно сказать о JS и используемых в рамках языка парадигмах программирования?",
    answerOptions: [
      {
        id: "1.3.1",
        name: "q1.3",
        value: "0",
        text: "JS поддерживает только императивный стиль программирования",
      },
      {
        id: "1.3.2",
        name: "q1.3",
        value: "0",
        text: "JS поддерживает только функциональный стиль программирования",
      },
      {
        id: "1.3.3",
        name: "q1.3",
        value: "1",
        text: "JS является мультипарадигменным языком программирования",
      },
      {
        id: "1.3.4",
        name: "q1.3",
        value: "0",
        text: "JS поддерживает только объектно-ориентированный стиль программирования",
      }
    ],
    feedbackText: "JavaScript — мультипарадигменный язык программирования. Поддерживает объектно-ориентированный, императивный и функциональный стили."
  },
  {
    questionText: "Какой вид типизации в JS?",
    answerOptions: [
      {
        id: "1.4.1",
        name: "q1.4",
        value: "1",
        text: "слабая типизация",
      },
      {
        id: "1.4.2",
        name: "q1.4",
        value: "0",
        text: "сильная типизация",
      },
      {
        id: "1.4.3",
        name: "q1.4",
        value: "0",
        text: "строгая типизация",
      }
    ],
    feedbackText: "JavaScript — это язык со слабой типизацией. Сильная и слабая типизация или строгая и нестрогая типизация — характеристика системы типов языка программирования, отражающая существенные ограничения на приведение типов при присваиваниях и операциях. Языки, в которых такие ограничения менее строгие, называют — слабо типизированными."
  },
  {
    questionText: "Чем отличаются ECMAScript и JavaScript?",
    answerOptions: [
      {
        id: "1.5.1",
        name: "q1.5",
        value: "0",
        text: "Это одно и то же",
      },
      {
        id: "1.5.2",
        name: "q1.5",
        value: "1",
        text: " ECMAScript это стандарт, а JavaScript его реализация",
      },
      {
        id: "1.5.3",
        name: "q1.5",
        value: "0",
        text: "ECMAScript является сильнотипизированным языком программирования, в отличие от JS",
      }
    ],
    feedbackText: "ECMAScript (или ES) — это спецификация. То есть набор правил и рекомендаций, которые должны соблюдаться языком, чтобы он считался совместимым с этой спецификацией. JavaScript (или JS) — это язык, который соответствует спецификации ECMAScript."
  },
  {
    questionText: "Что такое Объектная Модель Документа (DOM)?",
    answerOptions: [
      {
        id: "1.6.1",
        name: "q1.6",
        value: "0",
        text: "тескт ответа номер 1",
      },
      {
        id: "1.6.2",
        name: "q1.6",
        value: "0",
        text: "текст ответа номер 2",
      },
      {
        id: "1.6.3",
        name: "q1.6",
        value: "1",
        text: "это программный интерфейс (API) для HTML и XML документов.",
      }
    ],
    feedbackText: "Объектная Модель Документа (DOM) – это программный интерфейс (API) для HTML и XML документов. DOM предоставляет структурированное представление документа и определяет то, как эта структура может быть доступна из программ, которые могут изменять содержимое, стиль и структуру документа. HTML-код – это текст страницы, а DOM – это объект, созданный браузером при парсинге этого текста. "
  },
  {
    questionText: "Что такое Объектная модель браузера (BOM)?",
    answerOptions: [
      {
        id: "1.7.1",
        name: "q1.7",
        value: "1",
        text: "это дополнительные объекты, предоставляемые браузером (окружением), чтобы работать со всем, кроме документа",
      },
      {
        id: "1.7.2",
        name: "q1.7",
        value: "0",
        text: "текст ответа номер 2",
      },
      {
        id: "1.7.3",
        name: "q1.7",
        value: "0",
        text: "тескт ответа номер 3",
      }
    ],
    feedbackText: "Объектная модель браузера (BOM) — объекты, методы и свойства для работы с браузером. Основные объекты Browser Object Model: window, navigator, history, location, screen, document."
  },
  {
    questionText: "Почему внешние скрипты рекомендуется подключать в конце документа, перед закрывающим тегом body?",
    answerOptions: [
      {
        id: "1.8.1",
        name: "q1.8",
        value: "0",
        text: "тескт ответа номер 1",
      },
      {
        id: "1.8.2",
        name: "q1.8",
        value: "1",
        text: "Когда внешний скрипт подключается в начале документа, браузер начинает загружать его и пытается выполнить. И пока загрузка и выполнение скрипта не будут завершены, браузер не покажет часть документа, следующую после подключаемого файла",
      },
      {
        id: "1.8.3",
        name: "q1.8",
        value: "0",
        text: "тескт ответа номер 3",
      }
    ],
    feedbackText: "Дело в том, что при подсоединении внешнего скрипта между тегами head, веб-браузер в первую очередь загрузит и попытается выполнить именно его. И до тех пор, пока загрузка и выполнение не завершатся, веб-браузер не покажет оставшуюся часть документа. Всё вроде бы ничего, но что будет, если файл по каким-нибудь причинам станет загружаться медленно? В результате пользователи будут ждать загрузку этого файла, а ждать сейчас никто не любит, поэтому, скорее всего, пользователи отдадут предпочтение другому ресурсу. Чтобы этого не случилось, сегодня рекомендуют подключать scripts в конце документа, то есть непосредственно перед </body>."
  },
  {
    questionText: "Что делать, если по каким-то причинам нам требуется подключить внешний скрипт именно в начале документа?",
    answerOptions: [
      {
        id: "1.9.1",
        name: "q1.9",
        value: "1",
        text: "использовать атрибуты async и defer",
      },
      {
        id: "1.9.2",
        name: "q1.9",
        value: "0",
        text: "дублировать подключение скрипта в начале документа и перед закрывающим тегом body",
      },
      {
        id: "1.9.3",
        name: "q1.9",
        value: "0",
        text: "тескт ответа номер 3",
      }
    ],
    feedbackText: "Бывают ситуации, когда какая-нибудь библиотека требует подключения как раз таки в начале документа. В данных обстоятельствах пригодятся атрибуты async и defer — они дают возможность веб-браузеру выполнять асинхронную загрузку скриптов (веб-браузер начнёт загружать скрипт, не останавливая отображение контента)."
  },
  {
    questionText: "JS является компилируемым или интерепретируемым языком программирования?",
    answerOptions: [
      {
        id: "1.10.1",
        name: "q1.10",
        value: "1",
        text: "JS - интерепретируемый язык программирования",
      },
      {
        id: "1.10.2",
        name: "q1.10",
        value: "0",
        text: "JS - компилируемый язык программирования",
      }
    ],
    feedbackText: "JavaScript относится к интерпретируемым языкам. Для его запуска нужна специальная программа – интерпретатор. Например, когда JavaScript код выполняется на сервере, интерпретатором чаще всего выступает Node. js, когда на фронтенде — сам браузер."
  },
  {
    questionText: "В чем отличие между let и const?",
    answerOptions: [
      {
        id: "1.11.1",
        name: "q1.11",
        value: "0",
        text: "тескт ответа номер 1",
      },
      {
        id: "1.11.2",
        name: "q1.11",
        value: "0",
        text: "текст ответа номер 2",
      },
      {
        id: "1.11.3",
        name: "q1.11",
        value: "1",
        text: "переменные, объявленные с использованием let, могут обновляться в пределах их видимости, переменную, объявленную с помощью const, нельзя обновить",
      }
    ],
    feedbackText: "Использование let позволяет обновлять переменную, но не объявлять заново, а использование const не предполагает ни того, ни другого. Переменные всех видов поднимаются в верх своей области видимости."
  },
  {
    questionText: "Можно ли объявить повторно переменную, объявленную с помощью ключевого слова const?",
    answerOptions: [
      {
        id: "1.12.1",
        name: "q1.12",
        value: "0",
        text: "да",
      },
      {
        id: "1.12.2",
        name: "q1.12",
        value: "1",
        text: "нет",
      }
    ],
    feedbackText: "Переменные, объявленные с помощью const , называются «константами». Их нельзя изменить. Попытка сделать это приведёт к ошибке."
  },
  {
    questionText: "Имена переменных hello и heLLo ...",
    answerOptions: [
      {
        id: "1.13.1",
        name: "q1.13",
        value: "0",
        text: "являются одинаковыми именами, так можно обратиться к одной и той же переменной",
      },
      {
        id: "1.13.2",
        name: "q1.13",
        value: "0",
        text: "разные имена, первое имя принадлежит переменной, объявленной через const, второе - переменной, объявленной через let",
      },
      {
        id: "1.13.3",
        name: "q1.13",
        value: "1",
        text: "это разные имена, а значит две разные переменные",
      }
    ],
    feedbackText: "Имена переменных регистрозависимы, то есть имя hello и имя heLLo – это два разных имени, а значит и две переменные. Регистр в JavaScript имеет важное значение, никогда не забывайте про него."
  },
  {
    questionText: "Что произойдет, если объявить переменную с помощью const, но не инициализировать ее?",
    answerOptions: [
      {
        id: "1.14.1",
        name: "q1.14",
        value: "1",
        text: "мы получим синтаксическую ошибку",
      },
      {
        id: "1.14.2",
        name: "q1.14",
        value: "0",
        text: "код будет работать, т.к. сработает всплытие",
       
      },
      {
        id: "1.14.3",
        name: "q1.14",
        value: "0",
        text: "значение такой переменной станет равно null",
      
      }
    ],
    feedbackText: "Инициализация константы обязательна; необходимо указать значение одновременно с объявлением (смысл в том, что потом это значение изменить уже нельзя). Если объявить переменную через const и не задать ей начального значения, будет ошибка: Uncaught SyntaxError: Missing initializer in const declaration ."
  },
  {
    questionText: "Что недоступно JS в браузерном окружении?",
    answerOptions: [
      {
        id: "1.15.1",
        name: "q1.15",
        value: "0",
        text: "Запоминать данные на стороне клиента",
      
      },
      {
        id: "1.15.2",
        name: "q1.15",
        value: "1",
        text: "читать/записывать произвольные файлы на жёстком диске",
        
      },
      {
        id: "1.15.3",
        name: "q1.15",
        value: "0",
        text: "Получать и устанавливать куки",
    
      },
      {
        id: "1.15.4",
        name: "q1.15",
        value: "0",
        text: "Добавлять новый HTML-код на страницу",
     
      }
    ],
    feedbackText: "Объект navigator содержит информацию о браузере: название, версия, платформа, доступные плагины, доступ к буферу обмена и прочее. Это один из самых больших объектов в окружении. С помощью этого объекта можно узнать, разрешён ли доступ к кукам, получить доступ к буферу обмена, геолокации, узнать, с какого браузера пользователь смотрит на страницу через userAgent. Объект screen содержит информацию об экране браузера. Объект location даёт возможность узнать, на какой странице мы находимся (какой у неё URL) и перейти на другую страницу программно. Объект fetch предоставляет возможность работы с сетью, с его помощью можно отправлять запросы на сервер. history даёт доступ к истории браузера, которая ограничена текущей вкладкой. То есть с её помощью можно перейти на страницу назад, только если мы пришли с неё. localStorage, sessionStorage - Локальные хранилища используются, чтобы хранить какие-то данные в браузере пользователя."
  },
  {
    questionText: "Для чего используется директива 'use strict'?",
    answerOptions: [
      {
        id: "1.16.1",
        name: "q1.16",
        value: "1",
        text: "с помощью 'use strict' производится более строгая проверка кода на ошибки и генерируются ошибки при небезопасных действиях",
      
      },
      {
        id: "1.16.2",
        name: "q1.16",
        value: "0",
        text: "текст ответа номер 2",
        
      },
      {
        id: "1.16.3",
        name: "q1.16",
        value: "0",
        text: "тескт ответа номер 3",
      
      }
    ],
    feedbackText: "'use strict' включает строгий режим выполнения JavaScript. Эта строка должна располагаться в самом начале скрипта, иначе строгий режим не будет работать. В строгом режиме интерпретатор будет явно выбрасывать ошибки на действия, которые ранее пропускал."
  },
  {
    questionText: "Какая разница между префиксной и постфиксной формой записи оператора инкремента/декремента?",
    answerOptions: [
      {
        id: "1.17.1",
        name: "q1.17",
        value: "1",
        text: "Префиксная форма возвращает новое значение, в то время как постфиксная форма возвращает старое",
       
      },
      {
        id: "1.17.2",
        name: "q1.17",
        value: "0",
        text: "Постфиксная форма возвращает новое значение, в то время как префиксная форма возвращает старое",
        
      },
      {
        id: "1.17.3",
        name: "q1.17",
        value: "0",
        text: "Никакой разницы нет",
      
      }
    ],
    feedbackText: "Префиксные операторы ++x (--x) записывают в переменную x изменённое значение и его же возвращают вместо себя (в исходное выражение). Постфиксные операторы x++ (x--) возвращают вместо себя текущее значение переменной х, а потом записывают в x новое значение."
  },
  {
    questionText: "Оператор || выполняет следующие действия",
    answerOptions: [
      {
        id: "1.18.1",
        name: "q1.18",
        value: "0",
        text: "находит и возвращает первое истинное значение или undefined, если все операнды являются ложными",
        
      },
      {
        id: "1.18.2",
        name: "q1.18",
        value: "0",
        text: "находит и возвращает последнее истинное значение или первое значение, если все операнды являются ложными",
        
      },
      {
        id: "1.18.3",
        name: "q1.18",
        value: "1",
        text: "находит и возвращает первое истинное значение или последнее значение, если все операнды являются ложными",
       
      }
    ],
    feedbackText: "Оператор || выполняет следующие действия: Вычисляет операнды слева направо. Каждый операнд конвертирует в логическое значение. Если результат true, останавливается и возвращает исходное значение этого операнда. Если все операнды являются ложными (false), возвращает последний из них. Значение возвращается в исходном виде, без преобразования. Другими словами, цепочка ИЛИ || возвращает первое истинное значение или последнее, если такое значение не найдено."
  },
  {
    questionText: "Оператор && выполняет следующие действия",
    answerOptions: [
      {
        id: "1.19.1",
        name: "q1.19",
        value: "0",
        text: "находит и возвращает первое истинное значение или последнее, если все операнды являются false",
        
      },
      {
        id: "1.19.2",
        name: "q1.19",
        value: "1",
        text: "находит и возвращает первое ложное значение или последнее, если все операнды являются true",
       
      },
      {
        id: "1.19.3",
        name: "q1.19",
        value: "0",
        text: "находит и возвращает последнее ложное значение или первое, если все операнды являются true",
        
      }
    ],
    feedbackText: "Оператор && выполняет следующие действия: Вычисляет операнды слева направо. Каждый операнд преобразует в логическое значение. Если результат false, останавливается и возвращает исходное значение этого операнда. Если все операнды были истинными, возвращается последний. Другими словами, И возвращает первое ложное значение. Или последнее, если ничего не найдено. "
  },
  {
    questionText: "Оператор нулевого слияния...",
    answerOptions: [
      {
        id: "1.20.1",
        name: "q1.20",
        value: "1",
        text: "возвращает первый аргумент, если он не null/undefined, иначе второй",
       
      },
      {
        id: "1.20.2",
        name: "q1.20",
        value: "0",
        text: "преобразует значение в null",
      },
      {
        id: "1.20.3",
        name: "q1.20",
        value: "0",
        text: "преобразует значение в undefined",
      }
    ],
    feedbackText: "Оператор нулевого слияния ( ?? ) — это логический оператор, возвращающий значение правого операнда, если значение левого операнда содержит null или undefined , в противном случае возвращается значение левого операнда."
  },
]
