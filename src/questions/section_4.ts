import { QuestionCard } from "./types";
//Строки
export const questionCards_4: QuestionCard[] = [
  {
    questionText: "Какой результат мы увидим в консоли? let str = 'Hi'; str[0] = 'h'; console.log(str)",
    answerOptions: [
      {
        id: "4.1.1",
        name: "q4.1",
        value: "1",
        text: "Hi",
      },
      {
        id: "4.1.2",
        name: "q4.1",
        value: "0",
        text: "hi",
      },
      {
        id: "4.1.3",
        name: "q4.1",
        value: "0",
        text: "undefined",
      }
    ],
    feedbackText: "Содержимое строки в JavaScript нельзя изменить. Нельзя взять символ посередине и заменить его. Как только строка создана — она такая навсегда."
  },
  {
    questionText: "Какой результат мы получим при выводе в консоль? let str = 'Hello, World!'; console.log(str.indexOf('hello'))",
    answerOptions: [
      {
        id: "4.2.1",
        name: "q4.2",
        value: "0",
        text: "0",
      },
      {
        id: "4.2.2",
        name: "q4.2",
        value: "0",
        text: "undefined",
      },
      {
        id: "4.2.3",
        name: "q4.2",
        value: "1",
        text: "-1",
      }
    ],
    feedbackText: "метод str.indexOf(substr, pos) ищет подстроку substr в строке str, начиная с позиции pos, и возвращает позицию, на которой располагается первое совпадение, либо -1 при отсутствии совпадений. Поиск чувствителен к регистру. Необязательный второй аргумент позволяет начать поиск с определённой позиции."
  },
  {
    questionText: "Что мы получим в результате данного выражения? let str = 'Hello, world!'; if (str.indexOf('Hello')) { console.log ( 'Совпадение есть!' ) }",
    answerOptions: [
      {
        id: "4.3.1",
        name: "q4.3",
        value: "0",
        text: "Совпадение есть!",
      },
      {
        id: "4.3.2",
        name: "q4.3",
        value: "1",
        text: "в консоль ничего не выведется",
      },
      {
        id: "4.3.3",
        name: "q4.3",
        value: "0",
        text: "undefined",
      }
    ],
    feedbackText: "При проверке indexOf в условии if есть небольшое неудобство. Мы ищем подстроку 'Hello'  и она здесь есть, прямо на позиции 0. Но в консоли мы ничего не видим, т. к. str.indexOf('Hello') возвращает 0, и if решает, что тест не пройден. Поэтому надо делать проверку на -1: if (str.indexOf('Hello') != -1)"
  },
  {
    questionText: "Чем отличаются методы  str.includes(substr, pos) и str.indexOf(subst, pos)?",
    answerOptions: [
      {
        id: "4.4.1",
        name: "q4.4",
        value: "1",
        text: "str.includes возвращает true(если совпадение есть) или false(если нет), а str.indexOf - позицию, на которой располагается совпадение, или -1, если совпадений нет",
      },
      {
        id: "4.4.2",
        name: "q4.4",
        value: "0",
        text: "str.includes в качестве параметра pos может принимать отрицательное значение и начинать поиск с конца строки, в отличие от str.indexOf",
      },
      {
        id: "4.4.3",
        name: "q4.4",
        value: "0",
        text: "str.includes более современная версия str.indexOf, делает то же самое",
      }
    ],
    feedbackText: "Более современный метод str.includes(substr, pos) возвращает true, если в строке str есть подстрока substr, либо false, если нет. Это — правильный выбор, если нам необходимо проверить, есть ли совпадение, но позиция не нужна. Необязательный второй аргумент str.includes позволяет начать поиск с определённой позиции."
  },
  {
    questionText: "Что происходит, когда мы пытаемся добавить (или конкатенировать) строку и число? Например, console.log ( 12 + 'apple' );",
    answerOptions: [
      {
        id: "4.5.1",
        name: "q4.5",
        value: "0",
        text: "NaN",
      },
      {
        id: "4.5.2",
        name: "q4.5",
        value: "1",
        text: "'12apple'",
      },
      {
        id: "4.5.3",
        name: "q4.5",
        value: "0",
        text: "Type error",
      }
    ],
    feedbackText: "Бинарный оператор '+' не вызывает численного преобразования, если один из операндов является строкой. Попытка представить строку как число на самом деле не имеет смысла, но число как строку — имеет, поэтому браузер довольно умно преобразует число в строку и объединяет две строки вместе."
  },
  {
    questionText: "Какой результат мы увидим в консоли? console.log('А' > 'а')",
    answerOptions: [
      {
        id: "4.6.1",
        name: "q4.6",
        value: "0",
        text: "true",
      },
      {
        id: "4.6.2",
        name: "q4.6",
        value: "1",
        text: "false",
      },
    ],
    feedbackText: "Строки можно сравнивать между собой, для сравнения используется лексикографический порядок. Внутренний формат (кодировка) для строк в языке программирования JavaScript — всегда UTF-16. Это один из способов кодирования (форм представления) символов Юникода. В таблице Юникода кириллические буквы расположены в том порядке, в каком они расположены в русском алфавите. Это удобно для программирования сортировки слов на русском языке, потому что, как известно, при сортировке слова сравниваются побуквенно, а при сравнении букв сравниваются коды букв (числа) из таблицы Юникода. Главная особенность, которую нужно знать: прописные (большие) буквы сгруппированы отдельно, а строчные (маленькие) буквы — тоже отдельно. При этом группа прописных букв идет в таблице Юникода раньше (их коды меньше), чем группа строчных букв. Эти группы примыкают друг к другу. В результате получается, что при сравнении букв оказывается верным неравенство 'а' > 'Я', что противоречит алфавитному порядку, по которому должно быть верным противоположное неравенство 'а' < 'Я', ведь и прописная буква «Я», и строчная буква «я» в русском алфавите находятся в самом конце, а потому должны иметь самые большие коды и быть больше любых других букв русского алфавита. Т.о, строчные буквы больше заглавных."
  },
  {
    questionText: "У нас есть две строки: let str = 'hello, \nworld'; let str1 = 'hello, world'; В первой строке используется специальный символ переноса строки, который не отображается при выводе строки. Что мы увидим в консоли: console.log ( str.length === str1.length )?",
    answerOptions: [
      {
        id: "4.7.1",
        name: "q4.7",
        value: "1",
        text: "false",
      },
      {
        id: "4.7.2",
        name: "q4.7",
        value: "0",
        text: "true",
      },
    ],
    feedbackText: "Свойство length содержит длину строки. При определении длины строки нужно учитывать, что пробелы и различные знаки - это тоже часть строки. Каждый из них является отдельным символом. \n — всего лишь способ записать символ перевода строки, но сам перевод строки по своему смыслу – это один символ, правда, невидимый. "
  },
  {
    questionText: "Есть ли какая-то разница между методами str.slice и str.substring?",
    answerOptions: [
      {
        id: "4.8.1",
        name: "q4.8",
        value: "0",
        text: "нет, разницы нет. Рекомендуется использовать метод str.substring, т.к. он более современный",
      },
      {
        id: "4.8.2",
        name: "q4.8",
        value: "0",
        text: "да, разница есть: метод str.substring вторым параметром принимает длину извлекаемой части",
      },
      {
        id: "4.8.3",
        name: "q4.8",
        value: "1",
        text: "да, разница есть: метод str.substring не поддерживает отрицательные значения",
      }
    ],
    feedbackText: "str.substring(start [, end]) почти то же, что и str.slice(start [, end]). Метод slice Возвращает часть строки от start до (не включая) end, если аргумент end отсутствует, slice возвращает символы до конца строки. Также для start/end можно задавать отрицательные значения. Это означает, что позиция определена как заданное количество символов с конца строки. Метод substring возвращает часть строки между start и end (не включая) end, но можно задавать start больше end. Если start больше end, то метод substring сработает так, как если бы аргументы были поменяны местами. Отрицательные значения substring, в отличие от slice, не поддерживает, они интерпретируются как 0."
  },
  {
    questionText: "Имеется строка let str = 'Hello, world'; Мы хотим, чтоб первый символ стал строчным, как этого можно добиться?",
    answerOptions: [
      {
        id: "4.9.1",
        name: "q4.9",
        value: "0",
        text: "str[0].toLowerCase()",
      },
      {
        id: "4.9.2",
        name: "q4.9",
        value: "1",
        text: "str[0].toLowerCase() + str.slice(1)",
      },
    ],
    feedbackText: "Созданная строка является иммутабельной (immutable) и не может быть изменена."
  },
  {
    questionText: "Имеется строка let str = 'Hello, world!'; что мы получим, применив к ней метод replace: str.replace('world', 'Vasya'), а затем выведем в консоль console.log ( str ) ",
    answerOptions: [
      {
        id: "4.10.1",
        name: "q4.10",
        value: "0",
        text: "Hello, Vasya!",
      },
      {
        id: "4.10.2",
        name: "q4.10",
        value: "1",
        text: "Hello, world!",
      }
    ],
    feedbackText: "Метод replace не не изменяет объект String, на котором он вызывается. Он просто возвращает новую строку. Возвращаемое значение: Новая строка с некоторыми или всеми сопоставлениями шаблона, заменёнными на заменитель."
  },
  {
    questionText: "Имеется строка let hello = 'hello'.padStart(8); Какой результат мы увидим в консоли? console.log ( hello.length) ",
    answerOptions: [
      {
        id: "4.11.1",
        name: "q4.11",
        value: "1",
        text: "8",
      },
      {
        id: "4.11.2",
        name: "q4.11",
        value: "0",
        text: "5",
      },
      {
        id: "4.11.3",
        name: "q4.11",
        value: "0",
        text: "13",
      }
    ],
    feedbackText: "Методы padStart() и padEnd() растягивают строку на определенное количество символов и заполняют строку слева и справа соответственно. Вызов 'hello'.padStart(8) будет рястягивать строку 'hello' на 8 символов. То есть изначально в строке 'hello' 5 символов, значит, к ней будет добавлено 3 символа. При чем они будут добавлено в начале строки. По умолчанию добавляемые символы представляют пробелы. По умолчанию эти методы используют пробелы для заполнения, но в качестве второго параметра мы можем передать методам значение, которым надо дополнить строку: let hello = '123'.padStart(6, '0');  // '000123'"
  },
  {
    questionText: "Метод search(substr) ищет подстроку в строке и возвращает позицию совпадения. Есть ли какие-то отличия между методом search и методом indexOf?",
    answerOptions: [
      {
        id: "4.12.1",
        name: "q4.12",
        value: "0",
        text: "нет, метод search является современной реализацией indexOf",
      },
      {
        id: "4.12.2",
        name: "q4.12",
        value: "0",
        text: "да, метод search вернет массив, состоящий из позиций совпадения, если вхождений подстроки не одно",
      },
      {
        id: "4.12.3",
        name: "q4.12",
        value: "1",
        text: "да, метод search() не может принимать второй аргумент позиции начала, а метод indexOf() не может принимать регулярные выражения.",
      }
    ],
    feedbackText: "Два метода, indexOf() и search() принимают одни и те же аргументы (параметры) и возвращают одно и то же значение? Эти два метода НЕ равны. Вот отличия: Метод search() не может принимать второй аргумент позиции начала. Метод indexOf() не может принимать мощные значения поиска (регулярные выражения)."
  },
  {
    questionText: "Имеется строка str = 'Яблоко, Банан, Киви'; const res = str.slice(-11, -6); Что мы увидим в консоли? console.log ( res );",
    answerOptions: [
      {
        id: "4.13.1",
        name: "q4.13",
        value: "0",
        text: "Uncaught ReferenceError",
      },
      {
        id: "4.13.2",
        name: "q4.13",
        value: "1",
        text: "Банан",
      },
      {
        id: "4.13.3",
        name: "q4.13",
        value: "0",
        text: "aн, Ки",
      }
    ],
    feedbackText: "Синтаксис метода: str.slice(beginIndex[, endIndex]). beginIndex - индекс, с которого начинать извлечение (нумерация начинается с нуля). Если аргумент отрицателен, то трактуется как str.length + beginIndex (например, если beginIndex равен -11, то он трактуется как str.length - 11). Если beginIndex больше или равен str.length, возвращается пустая строка. endIndex - индекс, перед которым заканчивать извлечение (нумерация начинается с нуля). Символ по этому индексу не будет включён. Если *endIndex *опущен или является undefined или больше чем str.length, slice() извлечёт всё до конца строки. Если аргумент отрицателен, то трактуется как str.length + endIndex (например, если endIndex равен -3, то он трактуется как str.length - 3). Если endIndex указан и меньше startIndex, то возвращается пустая строка (например, slice(-1, -3) или slice(3, 1) вернут '')."
  },
  {
    questionText: "Имеется строка const str = 'Яблоко, Банан, Киви'; Что мы увидим в консоли? console.log ( str.split() )",
    answerOptions: [
      {
        id: "4.14.1",
        name: "q4.14",
        value: "0",
        text: "['Яблоко', 'Банан', 'Киви']",
      },
      {
        id: "4.14.2",
        name: "q4.14",
        value: "1",
        text: "['Яблоко, Банан, Киви']",
      },
      {
        id: "4.14.3",
        name: "q4.14",
        value: "0",
        text: "['Я', 'б', 'л', 'о', 'к', 'о', ',', ' ', 'Б', 'а', 'н', 'а', 'н', ',', ' ', 'К', 'и', 'в', 'и']",
      }
    ],
    feedbackText: "Строку можно преобразовать в массив с помощью split(). Метод split принимает необязательным параметром разделитель, с помощью которого строка будет разбита на элементы массива. Если разделитель опущен, возвращаемый массив будет содержать всю строку в индексе [0]. Если разделитель '', возвращаемый массив будет массивом одиночных символов."
  },
  // {
  //   questionText: "Текст вопроса",
  //   answerOptions: [
  //     {
  //       id: "4.15.1",
  //       name: "q4.15",
  //       value: "0",
  //       text: "текст ответа номер 1",
  //     },
  //     {
  //       id: "4.15.2",
  //       name: "q4.15",
  //       value: "1",
  //       text: "текст ответа  номер 2",
  //     },
  //     {
  //       id: "4.15.3",
  //       name: "q4.15",
  //       value: "0",
  //       text: "текст ответа номер 3",
  //     }
  //   ],
  //   feedbackText: "Текст обратной связи"
  // },
  // {
  //   questionText: "Текст вопроса",
  //   answerOptions: [
  //     {
  //       id: "4.16.1",
  //       name: "q4.16",
  //       value: "0",
  //       text: "текст ответа номер 1",
  //     },
  //     {
  //       id: "4.16.2",
  //       name: "q4.16",
  //       value: "0",
  //       text: "текст ответа  номер 2",
  //     },
  //     {
  //       id: "4.16.3",
  //       name: "q4.16",
  //       value: "1",
  //       text: "текст ответа номер 3",
  //     }
  //   ],
  //   feedbackText: "Текст обратной связи"
  // },
  // {
  //   questionText: "Текст вопроса",
  //   answerOptions: [
  //     {
  //       id: "4.17.1",
  //       name: "q4.17",
  //       value: "1",
  //       text: "текст ответа номер 1",
  //     },
  //     {
  //       id: "4.17.2",
  //       name: "q4.17",
  //       value: "0",
  //       text: "текст ответа  номер 2",
  //     },
  //     {
  //       id: "4.17.3",
  //       name: "q4.17",
  //       value: "0",
  //       text: "текст ответа номер 3",
  //     }
  //   ],
  //   feedbackText: "Текст обратной связи"
  // },
  // {
  //   questionText: "Текст вопроса",
  //   answerOptions: [
  //     {
  //       id: "4.18.1",
  //       name: "q4.18",
  //       value: "0",
  //       text: "текст ответа номер 1",
  //     },
  //     {
  //       id: "4.18.2",
  //       name: "q4.18",
  //       value: "1",
  //       text: "текст ответа  номер 2",
  //     },
  //     {
  //       id: "4.18.3",
  //       name: "q4.18",
  //       value: "0",
  //       text: "текст ответа номер 3",
  //     }
  //   ],
  //   feedbackText: "Текст обратной связи"
  // },
  // {
  //   questionText: "Текст вопроса",
  //   answerOptions: [
  //     {
  //       id: "4.19.1",
  //       name: "q4.19",
  //       value: "1",
  //       text: "текст ответа номер 1",
  //     },
  //     {
  //       id: "4.19.2",
  //       name: "q4.19",
  //       value: "0",
  //       text: "текст ответа  номер 2",
  //     },
  //     {
  //       id: "4.19.3",
  //       name: "q4.19",
  //       value: "0",
  //       text: "текст ответа номер 3",
  //     }
  //   ],
  //   feedbackText: "Текст обратной связи"
  // },
  // {
  //   questionText: "Текст вопроса",
  //   answerOptions: [
  //     {
  //       id: "4.20.1",
  //       name: "q4.20",
  //       value: "1",
  //       text: "текст ответа номер 1",
  //     },
  //     {
  //       id: "4.20.2",
  //       name: "q4.20",
  //       value: "0",
  //       text: "текст ответа  номер 2",
  //     },
  //     {
  //       id: "4.20.3",
  //       name: "q4.20",
  //       value: "0",
  //       text: "текст ответа номер 3",
  //     }
  //   ],
  //   feedbackText: "Текст обратной связи"
  // },
]
