import { QuestionCard } from "./types";
//Приведение типов, сравнение
export const questionCards_3: QuestionCard[] = [
  {
    questionText: "let а = '0'; console.log(Boolean(a)). Какой будет результат вывода в консоль?",
    answerOptions: [
      {
        id: "3.1.1",
        name: "q3.1",
        value: "0",
        text: "false",
      },
      {
        id: "3.1.2",
        name: "q3.1",
        value: "0",
        text: "Type error",
      },
      {
        id: "3.1.3",
        name: "q3.1",
        value: "1",
        text: "true",
      }
    ],
    feedbackText: "Функция Boolean преобразовывает переданное значение к логическом типу. Результатом выполнения функции будет либо true , либо false . При этом к false преобразовываются только: 0 , пустая строка, null , undefined , NaN . Все остальные значения (числа, строки, объекты, массивы, функции) преобразовываются к true ."
  },
  {
    questionText: "Что вернет данное выражение console.log(null + null);?",
    answerOptions: [
      {
        id: "3.2.1",
        name: "q3.2",
        value: "1",
        text: "0",
      },
      {
        id: "3.2.2",
        name: "q3.2",
        value: "0",
        text: "null",
      },
      {
        id: "3.2.3",
        name: "q3.2",
        value: "0",
        text: "NaN",
      }
    ],
    feedbackText: "null во время сложения приводится к нулю. Это логично, так как числовым значением «ничего» является как раз 0."
  },
  {
    questionText: "Что вернет данное выражение console.log(undefined + undefined);?",
    answerOptions: [
      {
        id: "3.3.1",
        name: "q3.3",
        value: "0",
        text: "0",
      },
      {
        id: "3.3.2",
        name: "q3.3",
        value: "0",
        text: "undefined",
      },
      {
        id: "3.3.3",
        name: "q3.3",
        value: "1",
        text: "NaN",
      }
    ],
    feedbackText: "во время сложения JavaScript пытается привести undefined к числу, но у него не получается и в результате мы получаем NaN."
  },
  {
    questionText: "В чем разница между оператором '==' и '===' ?",
    answerOptions: [
      {
        id: "3.4.1",
        name: "q3.4",
        value: "1",
        text: "при использовании оператора '==' происходит преобразование типов, при использовании оператора '===' преобразования типов не происходит",
      },
      {
        id: "3.4.2",
        name: "q3.4",
        value: "0",
        text: "в строгом режиме запрещено использовать оператор '==', разрешен оператор '==='",
      },
      {
        id: "3.4.3",
        name: "q3.4",
        value: "0",
        text: "оператор '==' для сравнения примитивов, '===' для сравнения составных типов",
      }
    ],
    feedbackText: "Сравнение бывает строгим и нестрогим. При строгом сравнении (===) интерпретатор учитывает типы сравниваемых значений. Когда же мы сравниваем значения нестрого между собой с помощью ==, JavaScript приводит типы самостоятельно."
  },
  {
    questionText: "const a = [1, 2, 3]; const b = [1, 2, 3]; console.log(a == b); Что будет в консоли?",
    answerOptions: [
      {
        id: "3.5.1",
        name: "q3.5",
        value: "0",
        text: "true",
      },
      {
        id: "3.5.2",
        name: "q3.5",
        value: "1",
        text: "false",
      },
    ],
    feedbackText: "Даже несмотря на то, что массивы содержат одни и те же числа, при сравнении они не являются «одинаковыми». Когда JavaScript сравнивает a и b, он, грубо говоря, «сравнивает места в памяти, на которые ссылаются эти переменные». У не примитивов, эти места — разные, из-за чего они считаются неодинаковыми."
  },
  {
    questionText: "К какому типу данных интерпретатор приведет примитивные значения при использовании оператора '+', если один из них строка?",
    answerOptions: [
      {
        id: "3.6.1",
        name: "q3.6",
        value: "0",
        text: "к числу",
      },
      {
        id: "3.6.2",
        name: "q3.6",
        value: "1",
        text: "к строке",
      },
    ],
    feedbackText: "Интерпретатор приведёт примитивные значения к строке, если мы используем +, когда один из операндов — строка."
  },
  {
    questionText: "Что мы увидим в консоли если попытаемся сложить объект с числом? const obj1 = {}; console.log(1 + obj1);",
    answerOptions: [
      {
        id: "3.7.1",
        name: "q3.7",
        value: "0",
        text: "NaN",
      },
      {
        id: "3.7.2",
        name: "q3.7",
        value: "0",
        text: "Type error",
      },
      {
        id: "3.7.3",
        name: "q3.7",
        value: "1",
        text: "'1[object Object]'",
      }
    ],
    feedbackText: "JavaScript неявно приводит и не примитивные значения. Интерпретатор приводит их к логическому, если мы используем && или ||. Объекты — всегда true. Чтобы определить, к строке приводить значение или к числу, JavaScript смотрит, какой из двух методов (valueOf() и toString()) в текущем объекте объявлен. 1.Если перед нами не объект Date, то метод valueOf() вызывается, обычно, первым (если не сильно углубляться в детали спецификации). 2.Если возвращённое после этого значение — это примитив, то возвращается оно. 3.Если нет, то вызывается другой метод (если valueOf() не вернул примитив, то вызывается toString() и наоборот). 4.Если после этого вернулся примитив, возвращается он. 5.Если даже после этого не вернулся примитив, то будет ошибка Uncaught TypeError: Cannot convert object to primitive value. Чтобы «сложить» число с объектом, вначале будет вызван obj1.valueOf(). Он вернёт объект (непримитив), после чего будет вызван obj1.toString(). 1 + '[object Object]'; '1' + '[object Object]'; '1[object Object]'"
  },
  { 
    questionText: "let id = Symbol('id'); alert(id); Что мы получим?",
    answerOptions: [
      {
        id: "3.8.1",
        name: "q3.8",
        value: "1",
        text: "TypeError",
      },
      {
        id: "3.8.2",
        name: "q3.8",
        value: "0",
        text: "id",
      },
      {
        id: "3.8.3",
        name: "q3.8",
        value: "0",
        text: "Symbol(id)",
      }
    ],
    feedbackText: "Большинство типов данных в JavaScript могут быть неявно преобразованы в строку. Например, функция alert принимает практически любое значение, автоматически преобразовывает его в строку, а затем выводит это значение, не сообщая об ошибке. Символы же особенные и не преобразуются автоматически. В данном случае alert выдаст ошибку: TypeError: Cannot convert a Symbol value to a string. Если же мы действительно хотим вывести символ с помощью alert, то необходимо явно преобразовать его с помощью метода .toString(), вот так: alert(id.toString()); // Symbol(id), теперь работает. Или мы можем обратиться к свойству symbol.description, чтобы вывести только описание: alert(id.description); // id"
  },
  {
    questionText: "console.log(null == undefined); Что мы увидим в консоли?",
    answerOptions: [
      {
        id: "3.9.1",
        name: "q3.9",
        value: "1",
        text: "true",
      },
      {
        id: "3.9.2",
        name: "q3.9",
        value: "0",
        text: "false",
      },
    ],
    feedbackText: "При нестрогом равенстве '==' эти значения равны друг другу и не равны никаким другим значениям. Это специальное правило языка."
  },
  {
    questionText: "console.log(null === undefined); Что мы увидим в консоли?",
    answerOptions: [
      {
        id: "3.10.1",
        name: "q3.10",
        value: "0",
        text: "true",
      },
      {
        id: "3.10.2",
        name: "q3.10",
        value: "1",
        text: "false",
      },
    ],
    feedbackText: "При строгом равенстве '===' эти значения различны, так как различны их типы."
  },
  {
    questionText: "Что мы увидим в консоли? console.log(null >= 0)",
    answerOptions: [
      {
        id: "3.11.1",
        name: "q3.11",
        value: "0",
        text: "false",
      },
      {
        id: "3.11.2",
        name: "q3.11",
        value: "1",
        text: "true",
      },
    ],
    feedbackText: "Нестрогое равенство и сравнения > < >= <= работают по-разному. Сравнения преобразуют null в число, рассматривая его как 0. Поэтому выражение null >= 0 истинно"
  },
  {
    questionText: "Что вернут эти выражения? 1.  undefined > 0; 2. undefined < 0; 3. undefined == 0",
    answerOptions: [
      {
        id: "3.12.1",
        name: "q3.12",
        value: "0",
        text: "true, true, false",
      },
      {
        id: "3.12.2",
        name: "q3.12",
        value: "0",
        text: "false, false, true",
      },
      {
        id: "3.12.3",
        name: "q3.12",
        value: "1",
        text: "false, false, false",
      }
    ],
    feedbackText: "Все три варианта вернут false. Почему же сравнение undefined с нулём всегда ложно? На это есть следующие причины: Сравнения undefined > 0 и undefined < 0 возвращают false, потому что undefined преобразуется в NaN, а NaN – это специальное числовое значение, которое возвращает false при любых сравнениях. Нестрогое равенство undefined == 0 возвращает false, потому что undefined равно только null, undefined и ничему больше."
  },
  {
    questionText: "Каким будет результат этого выражения: '2' > '12'?",
    answerOptions: [
      {
        id: "3.13.1",
        name: "q3.13",
        value: "0",
        text: "false",
      },
      {
        id: "3.13.2",
        name: "q3.13",
        value: "1",
        text: "true",
      },
    ],
    feedbackText: "Используется посимвольное сравнение. Первый символ первой строки '2' больше, чем первый символ второй - '1'."
  },
  {
    questionText: "Какой ответ мы увидим в консоли? const obj1 = {}; console.log(Boolean(obj1))",
    answerOptions: [
      {
        id: "3.14.1",
        name: "q3.14",
        value: "0",
        text: "Uncaught TypeError",
      },
      {
        id: "3.14.2",
        name: "q3.14",
        value: "1",
        text: "true",
      },
      {
        id: "3.14.3",
        name: "q3.14",
        value: "0",
        text: "false",
      }
    ],
    feedbackText: "В логическом контексте все объекты являются true, всё просто."
  },
  {
    questionText: "Что мы увидим в результате выполнения кода? const obj = {name: 'Vasya'}; alert(obj)",
    answerOptions: [
      {
        id: "3.15.1",
        name: "q3.15",
        value: "1",
        text: "[object Object]",
      },
      {
        id: "3.15.2",
        name: "q3.15",
        value: "0",
        text: "name: 'Vasya'",
      },
      {
        id: "3.15.3",
        name: "q3.15",
        value: "0",
        text: "Vasya",
      }
    ],
    feedbackText: "Если объект выводится через alert(obj), то происходит строковое преобразование. Стандартным строковым представлением пользовательского объекта является строка '[object Object]'."
  },
  {
    questionText: "Что мы увидим в результате выполнения кода? const obj = {name: 'Vasya', toString: function() {return 'Пользователь' + this.name}}; alert(obj)",
    answerOptions: [
      {
        id: "3.16.1",
        name: "q3.16",
        value: "0",
        text: "[object Object]",
      },
      {
        id: "3.16.2",
        name: "q3.16",
        value: "1",
        text: "Пользователь Vasya",
      },
      {
        id: "3.16.3",
        name: "q3.16",
        value: "0",
        text: "name: 'Vasya', toString: function() {return 'Пользователь' + this.name}",
      }
    ],
    feedbackText: "Если в объекте присутствует метод toString, который возвращает примитив, то он используется для преобразования. Результатом toString может быть любой примитив. Метод toString не обязан возвращать именно строку. Его результат может быть любого примитивного типа. Например, это может быть число, как в примере ниже: var obj = {toString: function() { return 123; }}; alert( obj ); // 123. Поэтому мы и называем его здесь «строковое преобразование», а не «преобразование к строке». "
  },
  {
    questionText: "Что будет результатом выполнения данного кода? alert( [1, 2] );",
    answerOptions: [
      {
        id: "3.17.1",
        name: "q3.17",
        value: "0",
        text: "[object Object]",
      },
      {
        id: "3.17.2",
        name: "q3.17",
        value: "1",
        text: "1, 2",
      },
      {
        id: "3.17.3",
        name: "q3.17",
        value: "0",
        text: "TypeError",
      }
    ],
    feedbackText: "Если объект выводится через alert(obj), то происходит строковое преобразование. Все объекты, включая встроенные, имеют свои реализации метода toString. toString для массивов выводит список элементов '1,2'"
  },
  {
    questionText: "Что будет результатом выполнения данного кода? alert( function() { console.log('this is function') } );",
    answerOptions: [
      {
        id: "3.18.1",
        name: "q3.18",
        value: "0",
        text: "[object Object]",
      },
      {
        id: "3.18.2",
        name: "q3.18",
        value: "0",
        text: "this is function",
      },
      {
        id: "3.18.3",
        name: "q3.18",
        value: "1",
        text: "function() { console.log('this is function') }",
      }
    ],
    feedbackText: "Если объект выводится через alert(obj), то происходит строковое преобразование. Все объекты, включая встроенные, имеют свои реализации метода toString. toString для функции выводит её код"
  },
  {
    questionText: "Что будет результатом выполнения данного кода? alert( +new Date() );",
    answerOptions: [
      {
        id: "3.19.1",
        name: "q3.19",
        value: "1",
        text: "кол-во миллисекунд, прошедших с 01.01.1970",
      },
      {
        id: "3.19.2",
        name: "q3.19",
        value: "0",
        text: "[object Object]",
      },
      {
        id: "3.19.3",
        name: "q3.19",
        value: "0",
        text: "TypeError",
      }
    ],
    feedbackText: "Для численного преобразования объекта используется метод valueOf, а если его нет – то toString. Метод valueOf обязан возвращать примитивное значение, иначе его результат будет проигнорирован. При этом – не обязательно числовое. У большинства объектов нет метода valueOf, поэтому численное и строковое преобразования для них работают одинаково. Исключением является объект Date, который поддерживает оба типа преобразований: alert( new Date() ); // toString: Дата в виде читаемой строки; alert( +new Date() ); // valueOf: кол-во миллисекунд, прошедших с 01.01.1970;"
  },
  {
    questionText: "Что мы увидим в консоли? const a = '1'; const b = '2'; console.log( a - b )",
    answerOptions: [
      {
        id: "3.20.1",
        name: "q3.20",
        value: "0",
        text: "NaN",
      },
      {
        id: "3.20.2",
        name: "q3.20",
        value: "1",
        text: "-1",
      },
      {
        id: "3.20.3",
        name: "q3.20",
        value: "0",
        text: "Syntax Error",
      }
    ],
    feedbackText: "Так как JavaScript это слабо типизированный язык, преобразование между разными типами может происходить автоматически, и это называется неявным преобразованием типов. Чаще всего это происходит когда вы применяете операторы к значениям разных типов, таких как 1 == null, 2 / `5`, null + new Date(), может происходить в зависимости от контекста, как например, в случае с if (value) {…}, где value будет приведено к булевому значению. Неявное численное преобразование вызывается, если применяются арифметические операторы (- + * / % ). Обратите внимание, что бинарный оператор + не вызывает численного преобразования, если один из операндов является строкой."
  },
   // {
  //   questionText: "Текст вопроса",
  //   answerOptions: [
  //     {
  //       id: "3.21.1",
  //       name: "q3.21",
  //       value: "1",
  //       text: "текст ответа номер 1",
  //     },
  //     {
  //       id: "3.21.2",
  //       name: "q3.21",
  //       value: "0",
  //       text: "текст ответа  номер 2",
  //     },
  //     {
  //       id: "3.21.3",
  //       name: "q3.21",
  //       value: "0",
  //       text: "текст ответа номер 3",
  //     }
  //   ],
  //   feedbackText: "Текст обратной связи"
  // },
]
