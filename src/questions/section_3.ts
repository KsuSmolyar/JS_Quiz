import { QuestionCard } from "./types";

export const questionCards_3: QuestionCard[] = [
  {
    questionText: "let а = '0'; console.log(Boolean(a)). Какой будет результат вывода в консоль?",
    answerOptions: [
      {
        id: "3.1.1",
        name: "q3.1",
        value: "0",
        text: "false",
      },
      {
        id: "3.1.2",
        name: "q3.1",
        value: "0",
        text: "Type error",
      },
      {
        id: "3.1.3",
        name: "q3.1",
        value: "1",
        text: "true",
      }
    ],
    feedbackText: "Функция Boolean преобразовывает переданное значение к логическом типу. Результатом выполнения функции будет либо true , либо false . При этом к false преобразовываются только: 0 , пустая строка, null , undefined , NaN . Все остальные значения (числа, строки, объекты, массивы, функции) преобразовываются к true ."
  },
  {
    questionText: "Что вернет данное выражение console.log(null + null);?",
    answerOptions: [
      {
        id: "3.2.1",
        name: "q3.2",
        value: "1",
        text: "0",
      },
      {
        id: "3.2.2",
        name: "q3.2",
        value: "0",
        text: "null",
      },
      {
        id: "3.2.3",
        name: "q3.2",
        value: "0",
        text: "NaN",
      }
    ],
    feedbackText: "null во время сложения приводится к нулю. Это логично, так как числовым значением «ничего» является как раз 0."
  },
  {
    questionText: "Что вернет данное выражение console.log(undefined + undefined);?",
    answerOptions: [
      {
        id: "3.3.1",
        name: "q3.3",
        value: "0",
        text: "0",
      },
      {
        id: "3.3.2",
        name: "q3.3",
        value: "0",
        text: "undefined",
      },
      {
        id: "3.3.3",
        name: "q3.3",
        value: "1",
        text: "NaN",
      }
    ],
    feedbackText: "во время сложения JavaScript пытается привести undefined к числу, но у него не получается и в результате мы получаем NaN."
  },
  {
    questionText: "В чем разница между оператором '==' и '===' ?",
    answerOptions: [
      {
        id: "3.4.1",
        name: "q3.4",
        value: "1",
        text: "при использовании оператора '==' происходит преобразование типов, при использовании оператора '===' преобразования типов не происходит",
      },
      {
        id: "3.4.2",
        name: "q3.4",
        value: "0",
        text: "в строгом режиме запрещено использовать оператор '==', разрешен оператор '==='",
      },
      {
        id: "3.4.3",
        name: "q3.4",
        value: "0",
        text: "оператор '==' для сравнения примитивов, '===' для сравнения составных типов",
      }
    ],
    feedbackText: "Сравнение бывает строгим и нестрогим. При строгом сравнении (===) интерпретатор учитывает типы сравниваемых значений. Когда же мы сравниваем значения нестрого между собой с помощью ==, JavaScript приводит типы самостоятельно."
  },
  {
    questionText: "const a = [1, 2, 3]; const b = [1, 2, 3]; console.log(a == b); Что будет в консоли?",
    answerOptions: [
      {
        id: "3.5.1",
        name: "q3.5",
        value: "0",
        text: "true",
      },
      {
        id: "3.5.2",
        name: "q3.5",
        value: "1",
        text: "false",
      },
    ],
    feedbackText: "Даже несмотря на то, что массивы содержат одни и те же числа, при сравнении они не являются «одинаковыми». Когда JavaScript сравнивает a и b, он, грубо говоря, «сравнивает места в памяти, на которые ссылаются эти переменные». У не примитивов, эти места — разные, из-за чего они считаются неодинаковыми."
  },
  {
    questionText: "К какому типу данных интерпретатор приведет примитивные значения при использовании оператора '+', если один из них строка?",
    answerOptions: [
      {
        id: "3.6.1",
        name: "q3.6",
        value: "0",
        text: "к числу",
      },
      {
        id: "3.6.2",
        name: "q3.6",
        value: "1",
        text: "к строке",
      },
    ],
    feedbackText: "Интерпретатор приведёт примитивные значения к строке, если мы используем +, когда один из операндов — строка."
  },
  {
    questionText: "Что мы увидим в консоли если попытаемся сложить объект с числом? const obj1 = {}; console.log(1 + obj1);",
    answerOptions: [
      {
        id: "3.7.1",
        name: "q3.7",
        value: "0",
        text: "NaN",
      },
      {
        id: "3.7.2",
        name: "q3.7",
        value: "0",
        text: "Type error",
      },
      {
        id: "3.7.3",
        name: "q3.7",
        value: "1",
        text: "'1[object Object]'",
      }
    ],
    feedbackText: "JavaScript неявно приводит и не примитивные значения. Интерпретатор приводит их к логическому, если мы используем && или ||. Объекты — всегда true. Чтобы определить, к строке приводить значение или к числу, JavaScript смотрит, какой из двух методов (valueOf() и toString()) в текущем объекте объявлен. 1.Если перед нами не объект Date, то метод valueOf() вызывается, обычно, первым (если не сильно углубляться в детали спецификации). 2.Если возвращённое после этого значение — это примитив, то возвращается оно. 3.Если нет, то вызывается другой метод (если valueOf() не вернул примитив, то вызывается toString() и наоборот). 4.Если после этого вернулся примитив, возвращается он. 5.Если даже после этого не вернулся примитив, то будет ошибка Uncaught TypeError: Cannot convert object to primitive value. Чтобы «сложить» число с объектом, вначале будет вызван obj1.valueOf(). Он вернёт объект (непримитив), после чего будет вызван obj1.toString(). 1 + '[object Object]'; '1' + '[object Object]'; '1[object Object]'"
  },
  { 
    questionText: "let id = Symbol('id'); alert(id); Что мы получим?",
    answerOptions: [
      {
        id: "3.8.1",
        name: "q3.8",
        value: "1",
        text: "TypeError",
      },
      {
        id: "3.8.2",
        name: "q3.8",
        value: "0",
        text: "id",
      },
      {
        id: "3.8.3",
        name: "q3.8",
        value: "0",
        text: "Symbol(id)",
      }
    ],
    feedbackText: "Большинство типов данных в JavaScript могут быть неявно преобразованы в строку. Например, функция alert принимает практически любое значение, автоматически преобразовывает его в строку, а затем выводит это значение, не сообщая об ошибке. Символы же особенные и не преобразуются автоматически. В данном случае alert выдаст ошибку: TypeError: Cannot convert a Symbol value to a string. Если же мы действительно хотим вывести символ с помощью alert, то необходимо явно преобразовать его с помощью метода .toString(), вот так: alert(id.toString()); // Symbol(id), теперь работает. Или мы можем обратиться к свойству symbol.description, чтобы вывести только описание: alert(id.description); // id"
  },
  {
    questionText: "console.log(null == undefined); Что мы увидим в консоли?",
    answerOptions: [
      {
        id: "3.9.1",
        name: "q3.9",
        value: "1",
        text: "true",
      },
      {
        id: "3.9.2",
        name: "q3.9",
        value: "0",
        text: "false",
      },
    ],
    feedbackText: "При нестрогом равенстве '==' эти значения равны друг другу и не равны никаким другим значениям. Это специальное правило языка."
  },
  {
    questionText: "console.log(null === undefined); Что мы увидим в консоли?",
    answerOptions: [
      {
        id: "3.10.1",
        name: "q3.10",
        value: "0",
        text: "true",
      },
      {
        id: "3.10.2",
        name: "q3.10",
        value: "1",
        text: "false",
      },
    ],
    feedbackText: "При строгом равенстве '===' эти значения различны, так как различны их типы."
  },
  {
    questionText: "Что мы увидим в консоли? console.log(null >= 0)",
    answerOptions: [
      {
        id: "3.11.1",
        name: "q3.11",
        value: "0",
        text: "false",
      },
      {
        id: "3.11.2",
        name: "q3.11",
        value: "1",
        text: "true",
      },
    ],
    feedbackText: "Нестрогое равенство и сравнения > < >= <= работают по-разному. Сравнения преобразуют null в число, рассматривая его как 0. Поэтому выражение null >= 0 истинно"
  },
  {
    questionText: "Что вернут эти выражения? 1.  undefined > 0; 2. undefined < 0; 3. undefined == 0",
    answerOptions: [
      {
        id: "3.12.1",
        name: "q3.12",
        value: "0",
        text: "true, true, false",
      },
      {
        id: "3.12.2",
        name: "q3.12",
        value: "0",
        text: "false, false, true",
      },
      {
        id: "3.12.3",
        name: "q3.12",
        value: "1",
        text: "false, false, false",
      }
    ],
    feedbackText: "Все три варианта вернут false. Почему же сравнение undefined с нулём всегда ложно? На это есть следующие причины: Сравнения undefined > 0 и undefined < 0 возвращают false, потому что undefined преобразуется в NaN, а NaN – это специальное числовое значение, которое возвращает false при любых сравнениях. Нестрогое равенство undefined == 0 возвращает false, потому что undefined равно только null, undefined и ничему больше."
  },
  {
    questionText: "Каким будет результат этого выражения: '2' > '12'?",
    answerOptions: [
      {
        id: "3.13.1",
        name: "q3.13",
        value: "0",
        text: "false",
      },
      {
        id: "3.13.2",
        name: "q3.13",
        value: "1",
        text: "true",
      },
    ],
    feedbackText: "Используется посимвольное сравнение. Первый символ первой строки '2' больше, чем первый символ второй - '1'."
  },
  // {
  //   questionText: "Текст вопроса",
  //   answerOptions: [
  //     {
  //       id: "3.14.1",
  //       name: "q3.14",
  //       value: "0",
  //       text: "текст ответа номер 1",
  //     },
  //     {
  //       id: "3.14.2",
  //       name: "q3.14",
  //       value: "1",
  //       text: "текст ответа  номер 2",
  //     },
  //     {
  //       id: "3.14.3",
  //       name: "q3.14",
  //       value: "0",
  //       text: "тескт ответа номер 3",
  //     }
  //   ],
  //   feedbackText: "Текст обратной связи"
  // },
  // {
  //   questionText: "Текст вопроса",
  //   answerOptions: [
  //     {
  //       id: "3.15.1",
  //       name: "q3.15",
  //       value: "1",
  //       text: "текст ответа номер 1",
  //     },
  //     {
  //       id: "3.15.2",
  //       name: "q3.15",
  //       value: "0",
  //       text: "текст ответа  номер 2",
  //     },
  //     {
  //       id: "3.15.3",
  //       name: "q3.15",
  //       value: "0",
  //       text: "тескт ответа номер 3",
  //     }
  //   ],
  //   feedbackText: "Текст обратной связи"
  // },
  // {
  //   questionText: "Текст вопроса",
  //   answerOptions: [
  //     {
  //       id: "3.16.1",
  //       name: "q3.16",
  //       value: "0",
  //       text: "текст ответа номер 1",
  //     },
  //     {
  //       id: "3.16.2",
  //       name: "q3.16",
  //       value: "1",
  //       text: "текст ответа  номер 2",
  //     },
  //     {
  //       id: "3.16.3",
  //       name: "q3.16",
  //       value: "0",
  //       text: "тескт ответа номер 3",
  //     }
  //   ],
  //   feedbackText: "Текст обратной связи"
  // },
  // {
  //   questionText: "Текст вопроса",
  //   answerOptions: [
  //     {
  //       id: "3.17.1",
  //       name: "q3.17",
  //       value: "0",
  //       text: "текст ответа номер 1",
  //     },
  //     {
  //       id: "3.17.2",
  //       name: "q3.17",
  //       value: "1",
  //       text: "текст ответа  номер 2",
  //     },
  //     {
  //       id: "3.17.3",
  //       name: "q3.17",
  //       value: "0",
  //       text: "тескт ответа номер 3",
  //     }
  //   ],
  //   feedbackText: "Текст обратной связи"
  // },
  // {
  //   questionText: "Текст вопроса",
  //   answerOptions: [
  //     {
  //       id: "3.18.1",
  //       name: "q3.18",
  //       value: "0",
  //       text: "текст ответа номер 1",
  //     },
  //     {
  //       id: "3.18.2",
  //       name: "q3.18",
  //       value: "0",
  //       text: "текст ответа  номер 2",
  //     },
  //     {
  //       id: "3.18.3",
  //       name: "q3.18",
  //       value: "1",
  //       text: "тескт ответа номер 3",
  //     }
  //   ],
  //   feedbackText: "Текст обратной связи"
  // },
  // {
  //   questionText: "Текст вопроса",
  //   answerOptions: [
  //     {
  //       id: "3.19.1",
  //       name: "q3.19",
  //       value: "1",
  //       text: "текст ответа номер 1",
  //     },
  //     {
  //       id: "3.19.2",
  //       name: "q3.19",
  //       value: "0",
  //       text: "текст ответа  номер 2",
  //     },
  //     {
  //       id: "3.19.3",
  //       name: "q3.19",
  //       value: "0",
  //       text: "тескт ответа номер 3",
  //     }
  //   ],
  //   feedbackText: "Текст обратной связи"
  // },
  // {
  //   questionText: "Текст вопроса",
  //   answerOptions: [
  //     {
  //       id: "3.20.1",
  //       name: "q3.20",
  //       value: "0",
  //       text: "текст ответа номер 1",
  //     },
  //     {
  //       id: "3.20.2",
  //       name: "q3.20",
  //       value: "1",
  //       text: "текст ответа  номер 2",
  //     },
  //     {
  //       id: "3.20.3",
  //       name: "q3.20",
  //       value: "0",
  //       text: "тескт ответа номер 3",
  //     }
  //   ],
  //   feedbackText: "Текст обратной связи"
  // },
]
